# Analysis-and-Design
1. What was the problem you were solving in the projects for this course?

The main problem was to create a program that could efficiently manage and retrieve course information from a file, allowing advisors to easily access course details, including prerequisites.  The goal was to enhance the advising process by providing a tool that facilitates informed decision-making regarding course selection.

2. How did you approach the problem? Consider why data structures are important to understand.

I approached the problem by first identifying the key requirements of the advising software, including loading course data, displaying courses in a structured format, and providing detailed information on individual courses.  Understanding and utilizing appropriate data structures was crucial;  I opted for a binary search tree (BST) because it allows for efficient insertion, searching, and in-order traversal, which is essential for sorting and retrieving course information in alphanumeric order.  This decision underscored the importance of data structures in optimizing performance and ensuring scalability within the software.

3. How did you overcome any roadblocks you encountered while going through the activities or project?

Throughout the project, I faced several challenges, particularly in parsing the course data from the file and implementing the BST correctly. Initially, I struggled with handling varying formats of prerequisites and ensuring they were stored accurately.  To overcome these roadblocks, I broke down the problem into smaller, manageable tasks and conducted thorough testing of each function individually.  I also referred to online resources and documentation to clarify the implementation of the BST.  Seeking feedback from peers and mentors helped refine my approach and enhance my understanding of the concepts.

4. How has your work on this project expanded your approach to designing software and developing programs?

This project significantly expanded my approach to software design by emphasizing the importance of modularity and organization.  I learned to structure my code into separate functions and classes that encapsulate specific functionalities, making it easier to read and maintain. Additionally, the experience highlighted the need to think critically about user interactions and the flow of data within the program, which has informed my approach to designing more user-centered applications in the future.

5. How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

My work on this project has evolved my coding practices in several ways:

Maintainability: I adopted clearer naming conventions and added comments throughout the code to explain complex logic, which improves the maintainability of the codebase.
Readability: By organizing code into functions and classes, I made it easier for others (and myself) to understand the program's structure and flow, reducing cognitive load when revisiting the code.
Adaptability: Understanding data structures better has prepared me to implement more complex algorithms and to adapt my code for future enhancements or changes in requirements. I now feel more confident in refactoring code and adding new features without disrupting existing functionality.
